# Goal and Conversation Linking API Documentation

**Date:** 2025-01-30  
**Status:** ‚úÖ Production Ready  
**API Version:** v1  
**Backend:** fit-iq-backend.fly.dev

---

## Overview

This document describes the API contract and implementation details for linking Goals with Chat Conversations in the Lume iOS app. The integration enables users to have contextual AI conversations about their wellness goals.

---

## Core Concepts

### Goal IDs: Local vs Backend

The Lume app maintains two types of identifiers for goals:

1. **Local ID** (`id: UUID`)
   - Generated by SwiftData
   - Used for local persistence and UI
   - Not sent to backend

2. **Backend ID** (`backendId: String`)
   - Generated by backend on goal creation
   - Required for all API interactions
   - Stored locally after sync

**Critical Rule:** All API requests MUST use the backend ID, never the local UUID.

### Conversation Linking

Goals and conversations are linked bidirectionally:
- Goals can reference a conversation ID
- Conversations can reference a goal ID
- Link is established through "Chat About Goal" feature

---

## API Endpoints

### 1. Create Conversation for Goal

**Endpoint:** `POST /api/v1/consultations/chat-about-goal`

**Purpose:** Creates a new consultation conversation linked to a specific goal, providing the AI with goal context.

**Request:**

```json
{
  "goalId": "backend-goal-id-string"
}
```

**Response:**

```json
{
  "conversationId": "uuid-v4-string",
  "goalId": "backend-goal-id-string",
  "createdAt": "2025-01-30T10:30:00Z",
  "persona": {
    "id": "persona-id",
    "name": "Wellness Coach",
    "avatar": "coach-avatar-url"
  }
}
```

**Status Codes:**
- `201 Created` - Conversation created successfully
- `400 Bad Request` - Invalid goal ID format
- `404 Not Found` - Goal does not exist
- `401 Unauthorized` - Invalid or missing auth token
- `500 Internal Server Error` - Server error

**Example Swift Implementation:**

```swift
struct ChatAboutGoalRequest: Codable {
    let goalId: String
}

struct ChatAboutGoalResponse: Codable {
    let conversationId: String
    let goalId: String
    let createdAt: Date
    let persona: PersonaInfo
}

func createConversationForGoal(_ goal: Goal) async throws -> String {
    guard let backendId = goal.backendId else {
        throw GoalSyncError.missingBackendId
    }
    
    let request = ChatAboutGoalRequest(goalId: backendId)
    let response: ChatAboutGoalResponse = try await apiClient.post(
        "/api/v1/consultations/chat-about-goal",
        body: request
    )
    
    return response.conversationId
}
```

---

### 2. Get Goal Details

**Endpoint:** `GET /api/v1/goals/{goalId}`

**Purpose:** Retrieve detailed goal information, including linked conversation.

**Response:**

```json
{
  "id": "backend-goal-id",
  "userId": "user-id",
  "title": "Exercise 3x per week",
  "description": "Build a consistent workout habit",
  "status": "in_progress",
  "progress": 0.45,
  "category": "fitness",
  "targetDate": "2025-03-01T00:00:00Z",
  "conversationId": "uuid-v4-or-null",
  "createdAt": "2025-01-15T08:00:00Z",
  "updatedAt": "2025-01-30T10:30:00Z"
}
```

**Status Codes:**
- `200 OK` - Goal retrieved successfully
- `404 Not Found` - Goal does not exist
- `401 Unauthorized` - Invalid auth token

---

### 3. Get Conversation Details

**Endpoint:** `GET /api/v1/consultations/{conversationId}`

**Purpose:** Retrieve conversation metadata, including linked goal.

**Response:**

```json
{
  "id": "conversation-uuid",
  "userId": "user-id",
  "goalId": "backend-goal-id-or-null",
  "persona": {
    "id": "persona-id",
    "name": "Wellness Coach",
    "avatar": "coach-avatar-url"
  },
  "createdAt": "2025-01-30T10:30:00Z",
  "updatedAt": "2025-01-30T11:45:00Z",
  "messageCount": 12,
  "lastMessageAt": "2025-01-30T11:45:00Z"
}
```

**Status Codes:**
- `200 OK` - Conversation retrieved successfully
- `404 Not Found` - Conversation does not exist
- `401 Unauthorized` - Invalid auth token

---

### 4. Update Goal (Link Conversation)

**Endpoint:** `PATCH /api/v1/goals/{goalId}`

**Purpose:** Update goal properties, including linking to a conversation.

**Request:**

```json
{
  "conversationId": "uuid-v4-string"
}
```

**Response:**

```json
{
  "id": "backend-goal-id",
  "userId": "user-id",
  "title": "Exercise 3x per week",
  "description": "Build a consistent workout habit",
  "status": "in_progress",
  "progress": 0.45,
  "category": "fitness",
  "targetDate": "2025-03-01T00:00:00Z",
  "conversationId": "uuid-v4-string",
  "createdAt": "2025-01-15T08:00:00Z",
  "updatedAt": "2025-01-30T12:00:00Z"
}
```

**Status Codes:**
- `200 OK` - Goal updated successfully
- `400 Bad Request` - Invalid request format
- `404 Not Found` - Goal does not exist
- `401 Unauthorized` - Invalid auth token

---

## Data Flow Diagrams

### Flow 1: Chat About Goal (From Goals Tab)

```
User taps "Chat" on Goal
    ‚Üì
GoalDetailView calls ViewModel
    ‚Üì
ViewModel: chatAboutGoal(goal)
    ‚Üì
Check: goal.backendId exists?
    ‚îú‚îÄ NO ‚Üí Sync goal first, get backend ID
    ‚îî‚îÄ YES ‚Üí Continue
    ‚Üì
POST /consultations/chat-about-goal
    body: { goalId: goal.backendId }
    ‚Üì
Backend creates conversation
    - Links goal ID to conversation
    - Returns conversation ID
    ‚Üì
Update local goal with conversationId
    ‚Üì
Navigate to ChatView(conversationId)
```

### Flow 2: Create Goal from Chat Suggestion

```
AI suggests goal in chat
    ‚Üì
User taps "Create Goal"
    ‚Üì
POST /goals
    body: { title, description, targetDate }
    ‚Üì
Backend creates goal, returns backend ID
    ‚Üì
Save to local SwiftData with backendId
    ‚Üì
PATCH /goals/{backendId}
    body: { conversationId: currentConversationId }
    ‚Üì
Backend links conversation to goal
    ‚Üì
Update local goal with conversationId
    ‚Üì
Show success confirmation
```

### Flow 3: Goal Sync with Conversation Link

```
App startup or background sync
    ‚Üì
Fetch all goals: GET /goals
    ‚Üì
For each backend goal:
    ‚îú‚îÄ Find local goal by backendId
    ‚îú‚îÄ If not found, create new local goal
    ‚îî‚îÄ Update properties including conversationId
    ‚Üì
Persist to SwiftData
    ‚Üì
Update UI
```

---

## Domain Models

### Goal Entity

```swift
struct Goal: Identifiable, Codable {
    let id: UUID                    // Local SwiftData ID
    let backendId: String?          // Backend goal ID (required for API)
    var title: String
    var description: String
    var createdAt: Date
    var targetDate: Date
    var progress: Double            // 0.0 to 1.0
    var status: GoalStatus
    var userId: String?
    var conversationId: String?     // Links to chat conversation
    var category: String?
}

enum GoalStatus: String, Codable {
    case notStarted = "not_started"
    case inProgress = "in_progress"
    case completed = "completed"
    case archived = "archived"
}
```

### Conversation Entity

```swift
struct Conversation: Identifiable, Codable {
    let id: UUID
    let backendId: String?
    var goalId: String?             // Links to backend goal ID
    let createdAt: Date
    var updatedAt: Date
    var persona: PersonaInfo
    var messageCount: Int
    var lastMessageAt: Date?
}

struct PersonaInfo: Codable {
    let id: String
    let name: String
    let avatar: String?
}
```

---

## Repository Implementation

### GoalRepository

```swift
protocol GoalRepositoryProtocol {
    func save(_ goal: Goal) async throws
    func fetch(id: UUID) async throws -> Goal?
    func fetchByBackendId(_ backendId: String) async throws -> Goal?
    func fetchAll() async throws -> [Goal]
    func update(_ goal: Goal) async throws
    func delete(_ goal: Goal) async throws
}

final class GoalRepository: GoalRepositoryProtocol {
    private let modelContext: ModelContext
    
    func fetchByBackendId(_ backendId: String) async throws -> Goal? {
        let descriptor = FetchDescriptor<SDGoal>(
            predicate: #Predicate { $0.backendId == backendId }
        )
        let sdGoals = try modelContext.fetch(descriptor)
        return sdGoals.first.map(toDomain)
    }
    
    func toDomain(_ sdGoal: SDGoal) -> Goal {
        Goal(
            id: sdGoal.id,
            backendId: sdGoal.backendId,
            title: sdGoal.title,
            description: sdGoal.goalDescription,
            createdAt: sdGoal.createdAt,
            targetDate: sdGoal.targetDate,
            progress: sdGoal.progress,
            status: GoalStatus(rawValue: sdGoal.status) ?? .notStarted,
            userId: sdGoal.userId,
            conversationId: sdGoal.conversationId,
            category: sdGoal.category
        )
    }
    
    func toSwiftData(_ goal: Goal) -> SDGoal {
        let sdGoal = SDGoal()
        sdGoal.id = goal.id
        sdGoal.backendId = goal.backendId
        sdGoal.title = goal.title
        sdGoal.goalDescription = goal.description
        sdGoal.createdAt = goal.createdAt
        sdGoal.targetDate = goal.targetDate
        sdGoal.progress = goal.progress
        sdGoal.status = goal.status.rawValue
        sdGoal.userId = goal.userId
        sdGoal.conversationId = goal.conversationId
        sdGoal.category = goal.category
        return sdGoal
    }
}
```

---

## Service Layer

### GoalSyncService

```swift
final class GoalSyncService {
    private let apiClient: APIClient
    private let goalRepository: GoalRepositoryProtocol
    
    func createConversationForGoal(_ goal: Goal) async throws -> String {
        // Ensure goal has backend ID
        guard let backendId = goal.backendId else {
            throw GoalSyncError.missingBackendId
        }
        
        // Create conversation linked to goal
        let request = ChatAboutGoalRequest(goalId: backendId)
        let response: ChatAboutGoalResponse = try await apiClient.post(
            "/api/v1/consultations/chat-about-goal",
            body: request
        )
        
        // Update local goal with conversation ID
        var updatedGoal = goal
        updatedGoal.conversationId = response.conversationId
        try await goalRepository.update(updatedGoal)
        
        return response.conversationId
    }
    
    func linkConversationToGoal(goalId: String, conversationId: String) async throws {
        // Update backend
        let request = UpdateGoalRequest(conversationId: conversationId)
        let _: Goal = try await apiClient.patch(
            "/api/v1/goals/\(goalId)",
            body: request
        )
        
        // Update local goal
        if let localGoal = try await goalRepository.fetchByBackendId(goalId) {
            var updatedGoal = localGoal
            updatedGoal.conversationId = conversationId
            try await goalRepository.update(updatedGoal)
        }
    }
    
    func syncGoal(_ goal: Goal) async throws {
        if let backendId = goal.backendId {
            // Update existing goal
            try await updateGoalOnBackend(goal)
        } else {
            // Create new goal
            let backendGoal = try await createGoalOnBackend(goal)
            
            // Update local goal with backend ID
            var updatedGoal = goal
            updatedGoal.backendId = backendGoal.id
            try await goalRepository.update(updatedGoal)
        }
    }
    
    private func createGoalOnBackend(_ goal: Goal) async throws -> BackendGoal {
        let request = CreateGoalRequest(
            title: goal.title,
            description: goal.description,
            targetDate: goal.targetDate,
            category: goal.category
        )
        
        return try await apiClient.post("/api/v1/goals", body: request)
    }
    
    private func updateGoalOnBackend(_ goal: Goal) async throws {
        guard let backendId = goal.backendId else {
            throw GoalSyncError.missingBackendId
        }
        
        let request = UpdateGoalRequest(
            title: goal.title,
            description: goal.description,
            targetDate: goal.targetDate,
            progress: goal.progress,
            status: goal.status.rawValue,
            conversationId: goal.conversationId,
            category: goal.category
        )
        
        let _: BackendGoal = try await apiClient.patch(
            "/api/v1/goals/\(backendId)",
            body: request
        )
    }
}

enum GoalSyncError: LocalizedError {
    case missingBackendId
    case syncFailed(Error)
    
    var errorDescription: String? {
        switch self {
        case .missingBackendId:
            return "Goal must be synced to backend before linking to conversation"
        case .syncFailed(let error):
            return "Failed to sync goal: \(error.localizedDescription)"
        }
    }
}
```

---

## ViewModel Integration

### GoalDetailViewModel

```swift
@MainActor
final class GoalDetailViewModel: ObservableObject {
    @Published var goal: Goal
    @Published var isLoadingChat = false
    @Published var chatError: String?
    
    private let goalSyncService: GoalSyncService
    
    func chatAboutGoal() async {
        isLoadingChat = true
        chatError = nil
        
        do {
            // Ensure goal has backend ID
            if goal.backendId == nil {
                try await goalSyncService.syncGoal(goal)
                // Refresh goal to get backend ID
                goal = try await goalRepository.fetch(id: goal.id) ?? goal
            }
            
            // Create or get conversation
            let conversationId: String
            if let existingConversationId = goal.conversationId {
                conversationId = existingConversationId
            } else {
                conversationId = try await goalSyncService.createConversationForGoal(goal)
                goal.conversationId = conversationId
            }
            
            // Navigate to chat
            navigationPath.append(.chat(conversationId: conversationId))
            
        } catch {
            chatError = error.localizedDescription
        }
        
        isLoadingChat = false
    }
}
```

### ChatViewModel

```swift
@MainActor
final class ChatViewModel: ObservableObject {
    @Published var goalContext: Goal?
    
    private let goalRepository: GoalRepositoryProtocol
    private let conversationService: ConversationService
    
    func loadGoalContext(conversationId: String) async {
        do {
            // Get conversation details
            let conversation = try await conversationService.getConversation(id: conversationId)
            
            // If conversation is linked to goal, load it
            if let goalId = conversation.goalId {
                goalContext = try await goalRepository.fetchByBackendId(goalId)
            }
        } catch {
            print("‚ö†Ô∏è Failed to load goal context: \(error)")
        }
    }
    
    func createGoalFromSuggestion(title: String, description: String) async throws {
        // Create goal on backend
        let request = CreateGoalRequest(
            title: title,
            description: description,
            targetDate: Date().addingTimeInterval(30 * 24 * 60 * 60) // 30 days
        )
        
        let backendGoal: BackendGoal = try await apiClient.post(
            "/api/v1/goals",
            body: request
        )
        
        // Save locally with backend ID
        let localGoal = Goal(
            id: UUID(),
            backendId: backendGoal.id,
            title: backendGoal.title,
            description: backendGoal.description,
            createdAt: backendGoal.createdAt,
            targetDate: backendGoal.targetDate,
            progress: 0.0,
            status: .notStarted
        )
        
        try await goalRepository.save(localGoal)
        
        // Link conversation to goal
        try await goalSyncService.linkConversationToGoal(
            goalId: backendGoal.id,
            conversationId: currentConversationId
        )
        
        // Update local context
        goalContext = localGoal
    }
}
```

---

## Error Handling

### Common Errors

1. **Missing Backend ID**
   ```swift
   throw GoalSyncError.missingBackendId
   // User message: "Please wait while we sync your goal..."
   ```

2. **Goal Not Found (404)**
   ```swift
   // Goal was deleted on backend but still exists locally
   // Action: Remove local goal or show "Goal no longer exists"
   ```

3. **Conversation Not Found (404)**
   ```swift
   // Conversation was deleted
   // Action: Clear conversationId from goal, show error
   ```

4. **Network Timeout**
   ```swift
   // Retry with exponential backoff
   // Show: "Connection issues, retrying..."
   ```

### Error Recovery Strategy

```swift
func chatAboutGoalWithRetry() async {
    var retryCount = 0
    let maxRetries = 3
    
    while retryCount < maxRetries {
        do {
            try await chatAboutGoal()
            return // Success
            
        } catch let error as URLError where error.code == .timedOut {
            retryCount += 1
            if retryCount < maxRetries {
                // Exponential backoff: 1s, 2s, 4s
                try? await Task.sleep(for: .seconds(pow(2.0, Double(retryCount - 1))))
            }
            
        } catch {
            // Non-retryable error
            chatError = error.localizedDescription
            return
        }
    }
    
    chatError = "Unable to connect. Please try again later."
}
```

---

## Testing

### Unit Tests

```swift
final class GoalSyncServiceTests: XCTestCase {
    func testCreateConversationRequiresBackendId() async throws {
        let goal = Goal(id: UUID(), backendId: nil, title: "Test")
        
        await XCTAssertThrowsError(
            try await goalSyncService.createConversationForGoal(goal)
        ) { error in
            XCTAssertEqual(error as? GoalSyncError, .missingBackendId)
        }
    }
    
    func testCreateConversationSuccess() async throws {
        let goal = Goal(
            id: UUID(),
            backendId: "backend-123",
            title: "Test Goal"
        )
        
        let conversationId = try await goalSyncService.createConversationForGoal(goal)
        
        XCTAssertFalse(conversationId.isEmpty)
        
        // Verify goal was updated locally
        let updatedGoal = try await goalRepository.fetch(id: goal.id)
        XCTAssertEqual(updatedGoal?.conversationId, conversationId)
    }
}
```

### Integration Tests

```swift
func testFullChatAboutGoalFlow() async throws {
    // 1. Create goal
    let goal = Goal(id: UUID(), title: "Exercise more")
    try await goalRepository.save(goal)
    
    // 2. Sync to backend (gets backend ID)
    try await goalSyncService.syncGoal(goal)
    let syncedGoal = try await goalRepository.fetch(id: goal.id)
    XCTAssertNotNil(syncedGoal?.backendId)
    
    // 3. Create conversation
    let conversationId = try await goalSyncService.createConversationForGoal(syncedGoal!)
    XCTAssertFalse(conversationId.isEmpty)
    
    // 4. Verify link in both directions
    let finalGoal = try await goalRepository.fetch(id: goal.id)
    XCTAssertEqual(finalGoal?.conversationId, conversationId)
    
    let conversation = try await conversationService.getConversation(id: conversationId)
    XCTAssertEqual(conversation.goalId, syncedGoal?.backendId)
}
```

---

## Migration Guide

### For Existing Goals Without Backend IDs

```swift
func migrateExistingGoals() async throws {
    let goals = try await goalRepository.fetchAll()
    let goalsWithoutBackendId = goals.filter { $0.backendId == nil }
    
    print("üîÑ Migrating \(goalsWithoutBackendId.count) goals...")
    
    for goal in goalsWithoutBackendId {
        do {
            try await goalSyncService.syncGoal(goal)
            print("‚úÖ Migrated goal: \(goal.title)")
        } catch {
            print("‚ùå Failed to migrate goal \(goal.title): \(error)")
        }
    }
    
    print("üéâ Migration complete")
}
```

---

## Summary

### Key Takeaways

1. **Always use backend IDs** for API calls, never local UUIDs
2. **Sync goals first** before creating conversations
3. **Bidirectional linking** keeps data consistent
4. **Handle missing backend IDs** gracefully with auto-sync
5. **Preserve partial data** on network errors

### Architecture Benefits

- Clean separation of concerns (Domain/Infrastructure)
- Type-safe ID handling (local vs backend)
- Resilient error handling and retry logic
- Offline-first with background sync
- Testable components at every layer

---

**Last Updated:** 2025-01-30  
**API Version:** v1  
**Next Review:** Before v2.0 release