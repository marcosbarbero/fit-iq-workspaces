# Goal Backend ID Fix

**Date:** 2025-01-17  
**Issue:** AI endpoints failing because wrong ID being used  
**Status:** ✅ Fixed

---

## Problem Description

The Goals AI endpoints (`/ai/suggestions`, `/ai/tips`, `/ai/analysis`) were failing or would fail when implemented because the code was using the **local iOS UUID** instead of the **backend-assigned ID**.

### The Two IDs

Every goal in the Lume app has TWO different IDs:

1. **Local UUID** (`Goal.id` / `SDGoal.id`)
   - Generated by the iOS app when goal is created
   - Used for SwiftData persistence and local operations
   - Example: `a1b2c3d4-e5f6-7890-abcd-ef1234567890`

2. **Backend ID** (`SDGoal.backendId`)
   - Assigned by the backend after sync
   - Returned in the `id` field of API responses
   - Required for all backend API operations
   - Example: `40020d52-dd54-40c2-a8c3-a75c645585f3`

### Why This Matters

The backend doesn't know about the local UUIDs. When you call:

```
GET /api/v1/goals/{goal_id}/ai/tips
```

The `{goal_id}` **MUST** be the backend-assigned ID, not the local UUID. Using the local UUID results in a `404 Goal Not Found` error.

---

## Root Cause

The `GoalBackendServiceProtocol` was incorrectly defined with `UUID` parameters:

```swift
// ❌ BEFORE (incorrect)
func getAITips(
    for goalId: UUID,  // This was the local UUID!
    accessToken: String
) async throws -> GoalAITips
```

This meant callers would naturally pass the local `goal.id`, which doesn't exist in the backend database.

---

## Solution

### 1. Changed Protocol Signatures

Updated all AI-related methods to accept `String` (backend ID) instead of `UUID`:

```swift
// ✅ AFTER (correct)
func getAITips(
    for backendId: String,  // Backend-assigned ID required!
    accessToken: String
) async throws -> GoalAITips
```

### 2. Updated API Paths

Also fixed the endpoint paths to include the `/ai/` prefix:

```swift
// ❌ BEFORE
path: "/api/v1/goals/\(goalId.uuidString)/tips"

// ✅ AFTER
path: "/api/v1/goals/\(backendId)/ai/tips"
```

### 3. Updated All Three AI Methods

- `getAISuggestions(for backendId: String, ...)`
- `getAITips(for backendId: String, ...)`
- `getProgressAnalysis(for backendId: String, ...)`

---

## How to Use Correctly

### Step 1: Fetch the SwiftData Goal

You need to get the `SDGoal` from SwiftData to access the `backendId`:

```swift
let descriptor = FetchDescriptor<SDGoal>(
    predicate: #Predicate { $0.id == localGoalId }
)
let sdGoals = try modelContext.fetch(descriptor)
guard let sdGoal = sdGoals.first else {
    throw GoalError.notFound
}
```

### Step 2: Check if Synced

Goals that haven't been synced yet won't have a `backendId`:

```swift
guard let backendId = sdGoal.backendId else {
    throw GoalError.notSynced  // Show "Syncing..." in UI
}
```

### Step 3: Call Backend Service

Now you can safely call the AI endpoints:

```swift
let tips = try await goalBackendService.getAITips(
    for: backendId,
    accessToken: accessToken
)
```

---

## Complete Example

```swift
// ViewModel or Use Case
func fetchAITipsForGoal(_ goal: Goal) async throws -> GoalAITips {
    // 1. Get access token
    guard let token = try await tokenStorage.getToken()?.accessToken else {
        throw AuthError.notAuthenticated
    }
    
    // 2. Fetch SDGoal to get backend ID
    let descriptor = FetchDescriptor<SDGoal>(
        predicate: #Predicate { $0.id == goal.id }
    )
    let sdGoals = try modelContext.fetch(descriptor)
    guard let sdGoal = sdGoals.first else {
        throw GoalError.notFound
    }
    
    // 3. Ensure goal has been synced
    guard let backendId = sdGoal.backendId else {
        // Goal not synced yet - trigger sync and show loading state
        throw GoalError.notSynced
    }
    
    // 4. Call backend with correct ID
    return try await goalBackendService.getAITips(
        for: backendId,
        accessToken: token
    )
}
```

---

## Outbox Sync Flow

Understanding when the `backendId` is set:

```
1. User creates goal
   └─> Local UUID assigned (e.g., abc-123)
   └─> Saved to SwiftData (backendId = nil)

2. Outbox event created
   └─> Event type: "goal.created"
   └─> Payload contains local UUID

3. OutboxProcessorService processes event
   └─> Calls POST /api/v1/goals
   └─> Backend creates goal and assigns ID (e.g., xyz-789)

4. Backend response received
   └─> Response contains backend ID in "id" field
   
5. Local goal updated
   └─> SDGoal.backendId = "xyz-789"
   └─> Now ready for AI endpoints!
```

---

## UI Handling for Unsynced Goals

When a goal hasn't been synced yet, the UI should:

### Option 1: Disable AI Features
```swift
// In View
.disabled(goalViewModel.backendId == nil)
.opacity(goalViewModel.backendId == nil ? 0.5 : 1.0)
.overlay {
    if goalViewModel.backendId == nil {
        Text("Syncing...")
            .font(.caption)
            .foregroundColor(.secondary)
    }
}
```

### Option 2: Show Loading State
```swift
if goalViewModel.isLoadingTips {
    ProgressView()
} else if let tips = goalViewModel.tips {
    TipsListView(tips: tips)
} else {
    Button("Get AI Tips") {
        await goalViewModel.fetchTips()
    }
    .disabled(goalViewModel.backendId == nil)
}
```

### Option 3: Auto-Retry with Polling
```swift
func fetchTipsWhenReady() async throws -> GoalAITips {
    for attempt in 1...5 {
        if let backendId = try? await getBackendId(for: goal) {
            return try await goalBackendService.getAITips(
                for: backendId,
                accessToken: token
            )
        }
        // Wait and retry
        try await Task.sleep(nanoseconds: 1_000_000_000)  // 1 second
    }
    throw GoalError.syncTimeout
}
```

---

## Testing Checklist

### Unit Tests
- [ ] Test that protocol methods require String parameter
- [ ] Test correct API path construction (`/ai/` prefix)
- [ ] Test that local UUID is never used in API calls

### Integration Tests
- [ ] Create goal and verify backendId is set after sync
- [ ] Call AI tips with backend ID and verify success
- [ ] Try calling AI tips before sync and verify error handling
- [ ] Verify 404 error if invalid backend ID used

### UI Tests
- [ ] Verify AI features disabled for unsynced goals
- [ ] Verify "Syncing..." state shows correctly
- [ ] Verify AI features become available after sync
- [ ] Verify error message for sync failures

---

## Related Files Modified

- `lume/lume/Services/Backend/GoalBackendService.swift`
  - Updated `GoalBackendServiceProtocol` signatures
  - Updated `GoalBackendService` implementation
  - Updated `InMemoryGoalBackendService` mock
  - Fixed API endpoint paths

---

## API Endpoint Reference

All goal operations that require the backend ID:

| Endpoint | Method | ID Required |
|----------|--------|-------------|
| `/api/v1/goals` | POST | ❌ No (creates new) |
| `/api/v1/goals/{id}` | PUT | ✅ Backend ID |
| `/api/v1/goals/{id}` | DELETE | ✅ Backend ID |
| `/api/v1/goals/{id}/suggestions` | POST | ✅ Backend ID |
| `/api/v1/goals/{id}/tips` | POST | ✅ Backend ID |
| `/api/v1/goals/{id}/analysis` | POST | ✅ Backend ID |

---

## Common Mistakes to Avoid

### ❌ Mistake 1: Using Local UUID
```swift
// WRONG - Will get 404 error
let tips = try await backendService.getAITips(
    for: goal.id,  // This is the local UUID!
    accessToken: token
)
```

### ❌ Mistake 2: Not Checking for Sync
```swift
// WRONG - Will crash if backendId is nil
let tips = try await backendService.getAITips(
    for: sdGoal.backendId!,  // Force unwrap is dangerous!
    accessToken: token
)
```

### ❌ Mistake 3: Converting UUID to String
```swift
// WRONG - Converting local UUID to string doesn't help
let tips = try await backendService.getAITips(
    for: goal.id.uuidString,  // Still wrong ID!
    accessToken: token
)
```

---

## Future Improvements

### Option 1: Add Helper Method to Repository
```swift
protocol GoalRepositoryProtocol {
    func getBackendId(for localId: UUID) async throws -> String
}

// Usage becomes simpler
let backendId = try await repository.getBackendId(for: goal.id)
let tips = try await backendService.getAITips(for: backendId, accessToken: token)
```

### Option 2: Create Dedicated Use Case
```swift
class GetGoalAITipsUseCase {
    func execute(goalId: UUID) async throws -> GoalAITips {
        // Handles all the ID resolution internally
        let backendId = try await resolveBackendId(localId: goalId)
        return try await backendService.getAITips(for: backendId, ...)
    }
}
```

### Option 3: Background Sync Monitoring
```swift
// Automatically enable AI features when sync completes
@Published var isGoalSynced: Bool = false

func monitorGoalSync(localId: UUID) {
    // Poll or observe backendId changes
    // Update UI state automatically
}
```

---

## Documentation References

- [Goals API Contract](../backend-integration/GOALS_API_CONTRACT.md) - Complete API reference with ID usage
- [Outbox Pattern](../backend-integration/OUTBOX_PATTERN_IMPLEMENTATION.md) - How sync works
- [Goal Date Decoding Fix](GOAL_DATE_DECODING_FIX.md) - Related backend integration fix

---

## Conclusion

The key takeaway: **Always use the backend-assigned ID for API calls, not the local UUID.**

This fix ensures that all AI features work correctly by using the proper backend ID that the server can recognize. The protocol-level change makes it a compile-time error to pass the wrong ID type, preventing runtime bugs.